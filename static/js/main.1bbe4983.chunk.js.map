{"version":3,"sources":["uitls/database.ts","uitls/converter.ts","uitls/styler.ts","store/actions.ts","types.ts","components/bookshelf/Bookshelf.tsx","uitls/common.ts","components/reader/Reader.tsx","App.tsx","store/reducers.ts","index.tsx"],"names":["DB_NAME","a","openDB","upgrade","db","createObjectStore","keyPath","autoIncrement","storeBook","text","fileMeta","tx","transaction","objectStore","add","primaryKey","record","id","name","page","done","bookId","book","get","then","oldBook","newBook","put","getAll","convertFB2ToHtml","bookText","parser","DOMParser","el","parseFromString","fetch","res","str","window","xsl","xsltProcessor","XSLTProcessor","importStylesheet","transformToDocument","indexes","Array","keys","sort","Math","random","stylize","html","querySelectorAll","forEach","paragraph","textContent","innerHTML","index","split","map","word","join","getStyledText","getBookText","dispatch","getBookTextFromStore","payload","type","fetchBooksList","getBookList","updateBookPosition","updateBook","connect","state","books","shelf","useDispatch","history","useHistory","className","htmlFor","src","alt","onChange","event","target","files","length","file","reader","FileReader","Promise","resolve","reject","onload","result","onerror","error","readAsText","readFileContent","body","addBook","accept","key","onClick","push","dfunc","func","waitFor","timeout","args","clearTimeout","setTimeout","debounce","fn","Reader","useState","pagesCount","setPagesCount","currentPage","setCurrentPage","queryParams","useParams","parseInt","useSelector","currentBook","find","handleScroll","e","pageWidth","getPageWidth","nextPage","round","container","scrollLeft","scrollToPage","document","getElementById","querySelector","containerElement","gapOffset","bookCS","getComputedStyle","columnGap","clientWidth","useEffect","limit","scrollWidth","ceil","getPagesCount","addEventListener","removeEventListener","handlePageChange","direction","to","dangerouslySetInnerHTML","__html","onWheel","sign","deltaY","deltaX","App","init","path","initialState","action","concat","app","rootReducer","combineReducers","store","createStore","composeWithDevTools","applyMiddleware","thunk","ReactDOM","render"],"mappings":"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","file":"static/js/main.1bbe4983.chunk.js","sourcesContent":["import { openDB, DBSchema } from 'idb'\n\ninterface ILibrarySchema extends DBSchema {\n  index: {\n    key: string\n    value: {}\n  }\n}\n\nconst DB_VERSION = 1\nconst DB_NAME = 'library'\nconst DB_INDEX_NAME = 'index'\nconst DB_STORE_NAME = 'books'\n\nasync function init() {\n  return openDB(DB_NAME, DB_VERSION, {\n    upgrade(db) {\n      db.createObjectStore(DB_INDEX_NAME, { keyPath: 'id' })\n      db.createObjectStore(DB_STORE_NAME, { autoIncrement: true })\n    },\n  })\n}\n\nasync function storeBook(text: string, fileMeta: File) {\n  const db = await openDB(DB_NAME, DB_VERSION)\n  const tx = db.transaction([DB_INDEX_NAME, DB_STORE_NAME], 'readwrite')\n  const primaryKey = await tx.objectStore(DB_STORE_NAME).add(text)\n  const record = {\n    id: primaryKey,\n    name: fileMeta.name,\n    page: 0,\n  }\n\n  tx.objectStore(DB_INDEX_NAME).add(record)\n  await tx.done\n  return record\n}\n\nasync function updateBook(bookId: number, book: any) {\n  const db = await openDB(DB_NAME, DB_VERSION)\n  const objectStore = db\n    .transaction([DB_INDEX_NAME], 'readwrite')\n    .objectStore(DB_INDEX_NAME)\n  return objectStore.get(bookId).then((oldBook) => {\n    const newBook = {\n      ...oldBook,\n      ...book,\n    }\n    return objectStore.put(newBook).then(() => newBook)\n  })\n}\n\nasync function getBookList() {\n  const db = await openDB(DB_NAME, DB_VERSION)\n  return db.getAll(DB_INDEX_NAME)\n}\n\nasync function getBookText(id: number) {\n  const db = await openDB(DB_NAME, DB_VERSION)\n  return db.get(DB_STORE_NAME, id)\n}\n\nexport { init, storeBook, getBookList, getBookText, updateBook }\n","export async function convertFB2ToHtml(bookText: string) {\n  const parser = new DOMParser()\n  const el = parser.parseFromString(bookText, 'text/xml')\n  return fetch('reader.xsl')\n    .then((res) => res.text())\n    .then((str) => new window.DOMParser().parseFromString(str, 'text/xml'))\n    .then((xsl: any) => {\n      const xsltProcessor = new XSLTProcessor()\n      xsltProcessor.importStylesheet(xsl)\n      return xsltProcessor.transformToDocument(el)\n    })\n}\n","const MAX_WORD_CLASSES = 100\nconst indexes = shuffle([...Array(MAX_WORD_CLASSES).keys()])\n\nfunction getStyledText(text: string): string {\n  // const separator = /(?:,| |&nbsp;|\\.)+/\n  const separator = ' '\n  let index = 0\n  return text\n    .split(separator)\n    .map((word: string) => {\n      index = index >= MAX_WORD_CLASSES ? 0 : index + 1\n      return `<span class=\"w${indexes[index]}\">${word}</span>`\n    })\n    .join(separator)\n}\n\nfunction shuffle<T>(array: Array<T>) {\n  return array.sort(() => Math.random() - 0.5)\n}\n\nexport function stylize(html: HTMLDocument) {\n  html.querySelectorAll('p').forEach((paragraph: HTMLParagraphElement) => {\n    if (paragraph.textContent) {\n      paragraph.innerHTML = getStyledText(paragraph.textContent)\n    }\n  })\n  return html\n}\n","import { ADD_BOOK, FETCH_BOOKS_LIST, UPDATE_BOOK_POSITION } from '../types'\nimport {\n  getBookList,\n  storeBook,\n  updateBook,\n  getBookText as getBookTextFromStore,\n} from '../uitls/database'\nimport { convertFB2ToHtml } from '../uitls/converter'\nimport { stylize } from '../uitls/styler'\n\nexport function addBook<IBook>(text: string, fileMeta: File) {\n  return async (dispatch: Function) => {\n    const html = await convertFB2ToHtml(text)\n    stylize(html)\n    const payload = await storeBook(html.body.innerHTML, fileMeta)\n    dispatch({\n      type: ADD_BOOK,\n      payload,\n    })\n  }\n}\n\nexport function getBookText(id: number) {\n  return (dispatch: Function) => {\n    getBookTextFromStore(id).then((payload) =>\n      dispatch({\n        type: 'BOOK_TEXT',\n        payload,\n      })\n    )\n  }\n}\n\nexport function fetchBooksList() {\n  return (dispatch: Function) => {\n    getBookList().then((payload) =>\n      dispatch({\n        type: FETCH_BOOKS_LIST,\n        payload,\n      })\n    )\n  }\n}\n\nexport function updateBookPosition(bookId: number, page: number) {\n  return (dispatch: Function) => {\n    updateBook(bookId, { page }).then((payload) =>\n      dispatch({\n        type: UPDATE_BOOK_POSITION,\n        payload,\n      })\n    )\n  }\n}\n","export interface Book {\n  id: number\n  name: string\n  page: number\n  author?: string\n  meta?: string\n}\n\nexport type BookList = Book[]\n\nexport interface BooksAction {\n  type: string\n  payload: any\n}\n\nexport const FETCH_BOOKS_LIST = 'FETCH_BOOKS_LIST'\nexport const ADD_BOOK = 'ADD_BOOK'\nexport const BOOK_TEXT = 'BOOK_TEXT'\nexport const UPDATE_BOOK_POSITION = 'UPDATE_BOOK_POSITION'\n\nexport interface BooksState {\n  list: BookList\n}\n\nexport interface ShelfState {\n  books: BookList\n  bookText: string\n  currentBook?: {\n    text: string\n    meta: string\n  }\n}\n\nexport interface AppState {}\n\nexport interface MainState {\n  shelf: ShelfState\n  app: AppState\n}\n","import React from 'react'\nimport { MainState, BookList, Book } from '../../types'\nimport { connect, useDispatch } from 'react-redux'\nimport { addBook } from '../../store/actions'\nimport { useHistory } from 'react-router-dom'\nimport { readFileContent } from '../../uitls/common'\nimport \"./Bookshelf.scss\"\ninterface IBookshelfProps {\n    books?: BookList\n}\n\nfunction Bookshelf({ books = [] }: IBookshelfProps) {\n    const dispatch = useDispatch()\n    let history = useHistory();\n\n    const onChangeHandler = (event: React.ChangeEvent<HTMLInputElement>) => {\n        if (event.target.files?.length) {\n            const file = event.target.files[0]\n            readFileContent(file)\n                .then((text: string) => {\n                    dispatch(addBook(text, file))\n                })\n        }\n    }\n\n    const onClick = (bookId: number) => {\n        history.push(`/read/${bookId}`)\n    }\n\n    return (\n        <div className=\"book-shelf\">\n\n            <label className=\"add-book-lable\" htmlFor=\"btn-add-book\">\n                <img src=\"add-book.png\" alt=\"\" />\n                <div className=\"add-book-text\">add book</div>\n                <input type=\"file\" name=\"\" id=\"btn-add-book\"\n                    onChange={onChangeHandler} accept=\".fb2\" />\n            </label>\n\n\n            <ul className=\"collection\">\n                {books.map((book: Book) => (\n                    <li className=\"list-item\" key={book.id} onClick={(event) => onClick(book.id)}>\n                        <div>{book.name}</div> <div>{book.page}</div>\n                    </li>\n                ))}\n            </ul>\n        </div>\n    )\n}\nconst mapStateToProps = (state: MainState) => {\n    return {\n        books: state.shelf.books\n    }\n}\nexport default connect(mapStateToProps, null)(Bookshelf)","/*\nREST API\n\n*/\nimport React from 'react'\nimport { Book, BookList } from '../types'\n\nexport async function getBooksList(): Promise<BookList> {\n  return fetch('db.json').then((resp) => resp.json())\n}\n\n/**\n * Register or update value for specified key.\n * @param key Key to identify value in container.\n * @param value Value to inject.\n * @returns Created or existing [DiRecord]{@link DiRecord}\n */\n\nexport async function getBook(filePath: string): Promise<string> {\n  return fetch(filePath).then((resp) => resp.text())\n}\n\nexport function readFileContent(file: File): Promise<string> {\n  const reader = new FileReader()\n\n  return new Promise((resolve, reject) => {\n    reader.onload = (event) => {\n      return resolve(event?.target?.result + '')\n    }\n    reader.onerror = (error) => reject('error reading file')\n    reader.readAsText(file)\n  })\n}\n\nexport const debounce = <F extends (...args: any[]) => any>(\n  func: F,\n  waitFor: number\n) => {\n  let timeout: ReturnType<typeof setTimeout> | null = null\n\n  const debounced = (...args: Parameters<F>) => {\n    if (timeout !== null) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    timeout = setTimeout(() => func(...args), waitFor)\n  }\n\n  return debounced as (...args: Parameters<F>) => ReturnType<F>\n}\n","import React, { useEffect, useState } from 'react'\nimport './Reader.scss'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { getBookText, updateBookPosition } from '../../store/actions'\nimport { MainState } from '../../types'\nimport { useParams, Link } from 'react-router-dom'\nimport { debounce } from '../../uitls/common'\n\ninterface QueryParams {\n    bookId: string\n}\nconst dfunc = debounce((fn) => fn && fn(), 500)\n\nexport default function Reader() {\n    const dispatch = useDispatch()\n    const [pagesCount, setPagesCount] = useState(0)\n    const [currentPage, setCurrentPage] = useState(1)\n    const queryParams = useParams<QueryParams>()\n    const bookId = parseInt(queryParams.bookId)\n\n    const bookText = useSelector((state: MainState) => {\n        return state.shelf.bookText\n    })\n    const currentBook = useSelector((state: MainState) => {\n        return state.shelf.books.find((book) => book.id === bookId)\n    })\n\n    useEffect(() => {\n        dispatch(getBookText(bookId))\n    }, [bookId])\n\n    useEffect(() => {\n        setPagesCount(getPagesCount())\n        if (currentBook && currentBook.page !== currentPage) {\n            scrollToPage(currentBook.page)\n        }\n    }, [bookText, currentBook])\n\n    useEffect(() => {\n        container().addEventListener('scroll', handleScroll)\n        return () => {\n            container().removeEventListener('scroll', handleScroll)\n        }\n    })\n\n    function handleScroll(e: Event) {\n        const pageWidth = getPageWidth()\n        const nextPage = Math.round((container().scrollLeft + pageWidth) / pageWidth)\n\n        if (nextPage !== currentPage) {\n            setCurrentPage(nextPage)\n            dfunc(dispatch(updateBookPosition(bookId, nextPage)))\n        }\n    }\n\n    function handleWheel(e: any) {\n        // container().scrollLeft += e.deltaY\n        const sign = e.deltaY > 0 || e.deltaX > 0 ? 1 : -1\n        const nextPage = currentPage + sign\n        scrollToPage(nextPage)\n    }\n\n    function scrollToPage(page: number) {\n        if (currentPage !== page) {\n            const pageWidth = getPageWidth()\n            container().scrollLeft = page * pageWidth - pageWidth\n        }\n    }\n\n    function getPagesCount() {\n        const limit = container().scrollWidth\n        const pageWidth = getPageWidth()\n        return Math.ceil(limit / pageWidth)\n    }\n\n    function container() {\n        return document.getElementById('book-container') || document.body\n    }\n\n    function getPageWidth() {\n        const book = document.querySelector('.book')\n        const containerElement = container()\n\n        let gapOffset = 0\n        if (book) {\n            const bookCS = window.getComputedStyle(book)\n            gapOffset = parseInt(bookCS.columnGap) / 2\n        }\n        return containerElement.clientWidth + gapOffset\n    }\n\n    const handlePageChange = (direction: string) => (e: React.MouseEvent) => {\n        const nextPage = direction === 'next' ? currentPage + 1 : currentPage - 1\n        scrollToPage(nextPage)\n    }\n\n    return (\n        <div className=\"reader\">\n            <div className=\"book-info\">\n                <Link to=\"/\"><div className=\"home\"></div></Link>\n                <div className=\"book-name\">{currentBook?.name}</div>\n                <div className=\"pages\">{currentPage} / {pagesCount}</div>\n            </div>\n            <div id=\"book-container\"\n                dangerouslySetInnerHTML={{ __html: bookText }}\n                onWheel={handleWheel}\n            >\n            </div>\n\n            <div className=\"prev-page\" onClick={handlePageChange('prev')}></div>\n            <div className=\"next-page\" onClick={handlePageChange('next')}></div>\n        </div>\n    )\n}\n","import React from 'react';\nimport './App.scss';\nimport Bookshelf from './components/bookshelf/Bookshelf'\nimport Reader from \"./components/reader/Reader\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route\n} from \"react-router-dom\";\nimport { useDispatch } from 'react-redux';\nimport { fetchBooksList } from './store/actions';\nimport { init } from './uitls/database';\n\nfunction App() {\n  const dispatch = useDispatch()\n  init()\n    .then(() => {\n      dispatch(fetchBooksList())\n    })\n\n  return (\n    <div className=\"reader-app\">\n      <Router>\n        <Switch>\n          <Route path=\"/read/:bookId\">\n            <Reader />\n          </Route>\n          <Route path=\"/\">\n            <Bookshelf />\n          </Route>\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","import {\n  FETCH_BOOKS_LIST,\n  BooksAction,\n  BOOK_TEXT,\n  ShelfState,\n  ADD_BOOK,\n  UPDATE_BOOK_POSITION,\n} from '../types'\n\nconst initialState: ShelfState = {\n  books: [],\n  bookText: '',\n}\n\nexport function ShelfReducer(state = initialState, action: BooksAction) {\n  switch (action.type) {\n    case ADD_BOOK:\n      return { ...state, books: state.books.concat(action.payload) }\n    case FETCH_BOOKS_LIST:\n      return { ...state, books: action.payload }\n    case BOOK_TEXT:\n      return {\n        ...state,\n        bookText: action.payload,\n      }\n    case UPDATE_BOOK_POSITION:\n      const newBook = action.payload\n      const books = state.books.map((book) => {\n        if (book.id === newBook.id) {\n          return newBook\n        }\n        return book\n      })\n\n      return { ...state, books }\n    default:\n      return state\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux'\nimport './index.css';\nimport App from './App';\nimport thunk from 'redux-thunk'\nimport * as serviceWorker from './serviceWorker';\nimport { createStore, applyMiddleware, combineReducers } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport { ShelfReducer } from './store/reducers';\n\nconst state = {\n  shelf: ShelfReducer,\n  app: (state = []) => state\n}\nconst rootReducer = combineReducers(state)\n\nconst store = createStore(rootReducer, composeWithDevTools(\n  applyMiddleware(\n    thunk\n  )))\n\n\n\nconst app = (\n  <Provider store={store}>\n    <App />\n  </Provider>\n)\n\nReactDOM.render(app, document.getElementById('root'))\n\n"],"sourceRoot":""}